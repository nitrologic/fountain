?Prompt error: InvalidData: Windows stdio in console mode does not support writing non-UTF-8 byte sequences
    at async Object.write (ext:deno_web/06_streams.js:1180:9) {
  name: "InvalidData"
}
error: Uncaught (in promise) BadResource: Bad resource ID
                console.log("[SHLOP] reset");


Enabling Mouse Reporting in ANSI Terminals
To detect mouse clicks, movements, and releases, you need to enable mouse tracking using
ANSI escape sequences. Most modern terminals (xterm, iTerm2, GNOME Terminal, Windows Terminal)
support this.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. Basic Mouse Reporting Modes
┌──────┬─────────────────┬─────────────┐
│  Mode │  Escape Sequence │  Description │
├──────┼─────────────────┼─────────────┤
│  Normal (Click Tracking) │  `\x1b[?1000h`  │  Reports mouse clicks & drags
(press/release). │
│  Extended (Motion Tracking) │  `\x1b[?1002h`  │  Reports mouse movement while a
button is held. │
│  Full (All Events) │  `\x1b[?1003h`  │  Reports all mouse movements (even without
clicks). │
└──────┴─────────────────┴─────────────┘

• Disable mouse reporting:*
`\x1b[?1000l` (or `1002l`, `1003l` for extended/full modes).

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

2. Mouse Event Format
When enabled, mouse actions send an escape sequence like:

\x1b[M<b><x><y>

- `<b>` = Button & action (encoded in a single byte).
- `<x>` & `<y>` = Column & row (1-based, ASCII-encoded).

Button Codes (`<b>`)
┌───────┬─────────┐
│  Value │  Meaning │
├───────┼─────────┤
│  `0x20` │  Left button press │
│  `0x23` │  Left button release │
│  `0x21` │  Middle button press │
│  `0x24` │  Middle button release │
│  `0x22` │  Right button press │
│  `0x25` │  Right button release │
│  `0x60` │  Scroll up │
│  `0x61` │  Scroll down │
└───────┴─────────┘

• (Note: Some terminals vary slightly in encoding.)*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

3. Example in Deno
Here’s how to enable mouse tracking in your `slopfountain.ts`:


// Enable mouse reporting (normal mode)
Deno.stdout.write(new TextEncoder().encode("\x1b[?1000h"));

// Set raw mode for input
Deno.stdin.setRaw(true);
const reader = Deno.stdin.readable.getReader();

while (true) {
  const { value } = await reader.read();
  const input = new TextDecoder().decode(value);

  // Check for mouse input
  if (input.startsWith("\x1b[M")) {
    const [_, b, x, y] = input.split("").map(c => c.charCodeAt(0));
    const button = b - 32; // Decode button
    const col = x - 32;    // Column (1-based)
    const row = y - 32;    // Row (1-based)

    console.log(`Mouse: button=${button}, x=${col}, y=${row}`);
  }

  // Exit on Ctrl+C
  if (input === "\x03") break;
}

// Disable mouse reporting before exit
Deno.stdout.write(new TextEncoder().encode("\x1b[?1000l"));
Deno.stdin.setRaw(false);


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

4. Handling Mouse Events
┌────────┬────────────────┬─────────┐
│  Action │  Example Output │  Meaning │
├────────┼────────────────┼─────────┤
│  Left-click at (10,5) │  `\x1b[M 0<10><5>` │  Press at column 10, row 5. │
│  Left-release │  `\x1b[M 3<10><5>` │  Release at same position. │
│  Right-click │  `\x1b[M 2<15><8>` │  Right press at (15,8). │
│  Scroll up │  `\x1b[M `\`<5><5>` │  `\` = 0x60 (scroll up). │
└────────┴────────────────┴─────────┘

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

5. Notes & Caveats
1. Terminal Compatibility:
   - Works in xterm, iTerm2, Windows Terminal, GNOME Terminal.
   - May not work in basic `cmd.exe` or `mintty`.

2. Coordinates:
   - `(1,1)` = Top-left corner (not `0,0`).
   - Some terminals report pixels (not cells) in extended modes.

3. Disable on Exit:
   - Always turn off mouse reporting (`\x1b[?1000l`) before exiting, or the terminal may
misbehave.

4. Drag Events:
   - Mode `1002` reports movement while a button is held.
   - Mode `1003` reports all movements (even without clicks).

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

6. Advanced: SGR Mode (Better Encoding)
For more precise reporting (like high-DPI mice), use SGR mode:

// Enable SGR mouse mode (better for modern terminals)
Deno.stdout.write(new TextEncoder().encode("\x1b[?1006h"));

// Example SGR event: `\x1b[<0;12;35M` = Left-click at (12,35)

- Format: `\x1b[<b;x;yM` (press) or `\x1b[<b;x;ym` (release).
- Works better with high-resolution mice.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Summary
✅ Enable mouse reporting with `\x1b[?1000h`.
📊 Decode events (`\x1b[M<b><x><y>`).
🚫 Disable with `\x1b[?1000l` before exiting.

Would you like a full implementation in `slopfountain.ts`? I can refine the mouse handling logic
further. 🐭

{account:deepseek,spent:0.0128,balance:-0.6814}
 fountain 1.3.2 ⛲  deepseek-chat 🐋 deepseek-chat@deepseek 1.0° 🪠 $0.013 111.6KB 48.54s 
>


//
📜
☯
🪣

//const toolKey={tools:"🪣",notool:"🐸",off:"🪠"};
//,"📘":"Inline","📘":"Inline" "📜"📠


class Item{
	role:string;
	name:sgtring;
	title:string;
	content:string;
}

class History{
	
}

class Payload{
	model:string="";
	messages:Item[]=[];
	tools:[]=[];
	temperature:number=1.0;
	max_tokens:{}={};
	config:{}={};
};


𓅷 𓅸 𓅹 𓅺 𓅻 𓅼 𓅽
> /model 18
model: {"id":0,"mut":"claude3haiku","emoji":"🌐","rate":[0.8,4],
"modelname":"claude-3-haiku-20240307@anthropic","balance":"$-8.7973",
"strict":true,"multi":false,"inline":false
}

purpose: fast speeds, improved instruction following, and more accurate tool use

> hi claude
+

Oops. invalid_request_error messages.0.content: Field required
Switch model, drop shares or reset history to continue.


// slopsite snapshot for worker refs

/*
import { resolve } from "https://deno.land/std/path/mod.ts";
import { _common } from "https://deno.land/std@0.224.0/path/_common/common.ts";

let verbose=false;

const rawPrompt=true;

let outputBuffer=[];
let printBuffer=[];
let markdownBuffer=[];

const exitMessage="Ending session.";

const AnsiDefault="\x1B[39m";
const AnsiPink="\x1B[38;5;206m";
const AnsiBlankLine="\x1B[0K";
const AnsiClear="\x1B[2J";
const AnsiHome="\x1B[H";
const AnsiCursor="\x1B[";

const AnsiMouseOn="\x1B[?1003h\x1B[?1015h\x1B[?1006h";
const AnsiMouseOff="\x1B[?1000l";

let consoleSize=Deno.consoleSize();

function AnsiPrompt(){
	const row=consoleSize.rows;
	return AnsiCursor + row + ";1H";// + AnsiBlankLine;
}

function toString(arg:any):string{
	if (typeof arg === 'object') {
		return JSON.stringify(arg);
	}
	return String(arg);
}

async function fileLength(path) {
	const stat=await Deno.stat(path);
	return stat.size;
}

function echo(...args:any[]){
//	const args=arguments.length?Array.from(arguments):[];
	const lines=[];
	for(const arg of args){
		const line=toString(arg);
		lines.push(line);
	}
	outputBuffer.push(lines.join(" "));
}

async function readFileNames(path:string,suffix:string){
	const result=[];
	try {
	for await (const entry of Deno.readDir(path)) {
		if (entry.isFile && entry.name.endsWith(suffix)) {
			if(verbose) echo("readFileNames",path,entry);
			result.push(entry.name);
		}
	}
	} catch (error) {
		echo("readFileNames:", error);
	}
	return result;
}

class Event{
	name: string;
	code: number[];
	constructor(name:string,code:number[]) {
		this.name=name;
		this.code=code;
	}
};

const appDir=Deno.cwd();
const slopPath=resolve(appDir,"../slop");

const slops:Worker[]=[];
const slopFrames:string[]=[];
const slopnames=await readFileNames(slopPath,".slop.ts");
const slopEvents:Event[]=[];

function onKey(value:number[]){
	const e=new Event("key",value);
	slopEvents.push(e);
}

function resetWorkers(){
	consoleSize=Deno.consoleSize();
	for(const worker of slops){
		console.log("[SLOP] worker reset");
		worker.postMessage({command:"reset",consoleSize});
	}
}

for(const name of slopnames){
	const path=slopPath+"/"+name;
	const len=await fileLength(path);
	echo("[SLOP] running slop",name,len);
	const url="file:///"+path;
	const worker=new Worker(url,{type: "module"});
	worker.onmessage = (message) => {
		const payload={...message.data};
		switch(payload.event){
			case "tick":
				if(payload.frame){
					slopFrames.push(payload.frame);
				}
				break;
			default:
				echo("[SLOP]",name,payload);
				break;
		}
	}
	slops.push(worker);
}

let slopPail:unknown[]=[];

function logSlop(_result:any){
	const message=JSON.stringify(_result);
	console.error("\t[slop]",message);
	slopPail.push(message);
}


async function sleep(ms:number) {
	await new Promise(function(resolve) {setTimeout(resolve, ms);});
}

function flushEvents(){
	const events:Event[]=[];
	if(slopEvents.length&&slopEvent<slopEvents.length){
		while(slopEvent<slopEvents.length){
			const _event:Event=slopEvents[slopEvent++];
			events.push(_event);
		}
	}
	return events;	
}

const decoder=new TextDecoder("utf-8");
const encoder=new TextEncoder();

let promptBuffer=new Uint8Array(0);
let slopFrame=0;
let slopEvent=0;
const reader=Deno.stdin.readable.getReader();
const writer=Deno.stdout.writable.getWriter();
async function refreshBackground(pause:number,line:string) {
	await new Promise(resolve => setTimeout(resolve, pause));
	const events=flushEvents();
	if(events.length){
		console.log("[SLOP] workers update",JSON.stringify(events));
		for(const worker of slops){
			worker.postMessage({command:"update",events});
		}			
	}
	if(slopFrames.length&&slopFrame!=slopFrames.length){
		slopFrame=slopFrames.length;
		const frame=slopFrames[slopFrame-1];
//		const message=AnsiHome + frame + AnsiCursor + row + ";1H\n" + prompt+line;
		const message=AnsiHome+frame+AnsiPrompt()+AnsiPink+line+AnsiDefault;
		await writer.write(encoder.encode(message));
		await writer.ready;
	}
}

// exitSlop 𓊽𓉴𓉴𓉴𓊽

function exitSlop(){
	Deno.stdin.setRaw(false);
	console.log("exitSlop",exitMessage);
}

// promptSlop 𓅠

async function promptSlop(message:string) {
	if(!rawPrompt) {
		const response=await prompt(message);
		return response;
	}
	let result="";
	if(message){
		await writer.write(encoder.encode(message));
		await writer.ready;
	}
	Deno.stdin.setRaw(true);
	const timer = setInterval(async() => {
		const line=decoder.decode(promptBuffer);
		await refreshBackground(5,message+line);
	}, 100);
	let busy=true;
	while (busy) {
		try {
//			const timeout = setTimeout(() => {refreshBackground(5)}, 1000); // 5-second timeout
			const { value, done }=await reader.read();
			if (done || !value) break;
			let bytes=[];
			for (const byte of value) {
				if (byte === 0x7F || byte === 0x08) { // Backspace
					if (promptBuffer.length > 0) {
						promptBuffer=promptBuffer.slice(0, -1);
						bytes.push(0x08, 0x20, 0x08);
					}
				} else if (byte === 0x1b) { // Escape sequence
					if (value.length === 1) {
						exitSlop();
						Deno.exit(0);
					}
					onKey(value);
					if (value.length === 3) {
						if (value[1] === 0xf4 && value[2] === 0x50) {
							echo("F1");
						}
					}
					break;
				} else if (byte === 0x0A || byte === 0x0D) { // Enter key
					bytes.push(0x0D, 0x0A);
					const line=decoder.decode(promptBuffer);
					let n=line.length;
					if (n > 0) {
						promptBuffer=promptBuffer.slice(n);
					}
					result=line.trimEnd();
					echo("[stdin]",result);
					busy=false;
				} else if (byte==0x09){
					onKey([0]);
				} else {
					bytes.push(byte);
					const buf=new Uint8Array(promptBuffer.length + 1);
					buf.set(promptBuffer);
					buf[promptBuffer.length]=byte;
					promptBuffer=buf;
				}
			}
			if (bytes.length) await writer.write(new Uint8Array(bytes));
		}catch(error){
			console.error("Prompt error:", error);
			busy=false;
		}
	}
	clearInterval(timer);
	Deno.stdin.setRaw(false);
	return result;
}

console.log("slop 0.1 mouse is on"+AnsiMouseOn);

while(true){
	const input=await(promptSlop(">"));
	if(input=="exit") break;
	if(input==""){
		console.log("[SLOP] reset");
		resetWorkers();
		continue;
	}
	console.log("[SLOP] ",input);
}


console.log("oh no, bye, mouse off");
console.log(AnsiMouseOff);

exitSlop();
Deno.exit(0);
*/

GEMINI {
	"name":"models/gemini-2.5-flash-preview-tts",
	"version":"gemini-2.5-flash-exp-tts-2025-05-19",
	"displayName":"Gemini 2.5 Flash Preview TTS",
	"description":"Gemini 2.5 Flash Preview TTS",
	"inputTokenLimit":8192,
	"outputTokenLimit":16384,
	"supportedGenerationMethods":["countTokens","generateContent"],
	"temperature":1,
	"topP":0.95,
	"topK":64,
	"maxTemperature":2
}

"topP":0.95,"topK":64,"maxTemperature":2

## yet another new name

![Slop Welcome](slop/slopwelcome.png)


+Here's a markdown table test with Chinese mythological creatures:

┌───────────────────┬──────────────────────────────────────┬─────────────────────┐
│  Creature          │  Description                          │  Symbolism           │
├───────────────────┼──────────────────────────────────────┼─────────────────────┤
│  龙 (Lóng)        │  Celestial dragon, controls water     │  Imperial power      │
│  凤凰 (Fènghuáng) │  Immortal fire bird                   │  Harmony, renewal    │
│  麒麟 (Qílín)     │  Hybrid beast with antlers/scales      │  Auspicious omen     │
│  白虎 (Báihǔ)     │  White tiger of the west               │  Martial prowess     │
└───────────────────┴──────────────────────────────────────┴─────────────────────┘

Let me know if you'd like:
- Different styling (e.g., box-drawing chars)
- Additional columns/rows
- Embedded code blocks

• (Tables render differently per client - this should align cleanly in standard markdown viewers.)*

 fountain 1.2.6 ⛲  deepseekchat 🐋 deepseek-chat@deepseek 1.0° 🪠 $0.009 98.47KB 13.20s 
>this needs spacing rule
+Slop Fountain has crashed, darn, this release will be stable soon: ReferenceError: error is not defined
    at promptForge (file:///C:/nitrologic/fountain/roha/fountain.js:1820:35)
    at eventLoopTick (ext:core/01_core.js:178:7)
    at async chat (file:///C:/nitrologic/fountain/roha/fountain.js:2967:10)
    at async file:///C:/nitrologic/fountain/roha/fountain.js:3161:2
error: Uncaught (in promise) BadResource: Bad resource ID
                console.log(line);
                        ^
    at Object.print (ext:core/01_core.js:678:28)
    at Console.<anonymous> (ext:runtime/98_global_scope_shared.js:136:46)
    at console.log (ext:deno_console/01_console.js:3139:20)
    at flush (file:///C:/nitrologic/fountain/roha/fountain.js:625:11)
    at exitForge (file:///C:/nitrologic/fountain/roha/fountain.js:198:8)
    at eventLoopTick (ext:core/01_core.js:178:7)
    at async file:///C:/nitrologic/fountain/roha/fountain.js:3164:2


	

const rulbreak500="─┬──┴".repeat(100);
const pageRule=rule500;
# interface

[model-name@account temperature° $cost.000 context.00KB time.00s]

# commands

/model [id] [all]

/share [folder]

/push

* discuss with model under test here

exit


> /commit
[DeepSeek] not ok 400 Bad Request
[FOUNTAIN] unhandled error DeepSeek API error
[FOUNTAIN] Error: DeepSeek API error
    at Object.create (file:///C:/nitrologic/fountain/roha/fountain.js:1191:14)
    at eventLoopTick (ext:core/01_core.js:178:7)
    at async relay (file:///C:/nitrologic/fountain/roha/fountain.js:2722:20)
    at async chat (file:///C:/nitrologic/fountain/roha/fountain.js:3003:5)
    at async file:///C:/nitrologic/fountain/roha/fountain.js:3145:2
>


[FOUNTAIN] unhandled error DeepSeek API error: Bad Request "Error: DeepSeek API error:

 Bad Request
     at Object.create (file:///C:/nitrologic/fountain/roha/fountain.js:1190:14)
	     at eventLoopTick (ext:core/01_core.js:178:7)
		     at async relay (file:///C:/nitrologic/fountain/roha/fountain.js:2721:20)
			     at async chat (file:///C:/nitrologic/fountain/roha/fountain.js:3001:5)
				     at async file:///C:/nitrologic/fountain/roha/fountain.js:3143:2"

𓏢 harp
𓏣 sistrum

• Coptic (Sahidic Dialect):*
Ⲛⲓⲙ ⲛⲁⲣⲓⲭⲣⲓⲥⲧⲟⲥ ⲙⲡⲓⲟⲩⲱⲛϩ ⲉⲃⲟⲗ.
Ⲡⲉⲛⲓⲱⲧ ⲉϥϯⲙⲉ ⲙⲙⲟⲛ.

• English:*
"We are Christians of the true light.
Our Father gives wisdom daily."

This uses:
- Standard Sahidic Coptic vocabulary
- The Coptic alphabet from your bibli.json (ⲁ-ⲱ + Ϣ-Ϯ)
- Simple grammatical structure


https://en.wikipedia.org/wiki/List_of_Egyptian_hieroglyphs

𓄰𓄱𓄲𓄳𓄴𓄵𓄶𓄷𓄱𓄰

𓄸

//			const timeout = setTimeout(() => {refreshBackground(5)}, 1000); // 5-second timeout


async function promptForge2(message) {
	if(!roha.config.rawprompt) return prompt(message);
	let result="";
	if (message) {
		await writer.write(encoder.encode(message));
		await writer.ready;
	}
	if(roha.config.page) {
		await writer.write(homeCursor);
	}
	Deno.stdin.setRaw(true);
	try {
		let busy=true;
		while (busy) {
			const { value, done }=await reader.read();
			if (done || !value) break;
			let bytes=[];
			for (const byte of value) {
				if (byte === 0x7F || byte === 0x08) { // Backspace
					if (promptBuffer.length > 0) {
						promptBuffer=promptBuffer.slice(0, -1);
						bytes.push(0x08, 0x20, 0x08);
					}
				} else if (byte === 0x1b) { // Escape sequence
					if (value.length === 1) {
						await exitForge();
						Deno.exit(0);
					}
					if (value.length === 3) {
						if (value[1] === 0xf4 && value[2] === 0x50) {
							echo("F1");
						}
					}
					break;
				} else if (byte === 0x0A || byte === 0x0D) { // Enter key
					bytes.push(0x0D, 0x0A);
					const line=decoder.decode(promptBuffer);
					let n=line.length;
					if (n > 0) {
						promptBuffer=promptBuffer.slice(n);
					}
					result=line.trimEnd();
					await log(result, "stdin");
					busy=false;
				} else {
					bytes.push(byte);
					const buf=new Uint8Array(promptBuffer.length + 1);
					buf.set(promptBuffer);
					buf[promptBuffer.length]=byte;
					promptBuffer=buf;
				}
			}
			if (bytes.length) await writer.write(new Uint8Array(bytes));
		}
	}catch(e){
		echo("promptForge","threw",e);
	} finally {
		Deno.stdin.setRaw(false);
	}
	if(roha.config.page) await writer.write(homeCursor);
	return result;
}


bibli.spec.unicode.lexis.𓅷𓅽

"latin": {
"name": "Latin",
"description": "Latin linguistic roots and Unicode characters",
"alphabet": {
"lower": "abcdefghijklmnopqrstuvwxyz",
"upper": "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
"uncommon": "ÆæŒœÞþÐðƷʒȜȝ"
},
"lingua": {
"core": "verbum nomen ratio vox forma scriptum",
"verbs": "ago dico facio scribo video voco",
"concepts": "veritas virtus tempus lex ars scientia",
"ends": {
"noun": "us a um io ix io",
"verb": "are ere ire ior",
"abstract": "tio io tas men",
"agent": "tor trix or"
}
},

moueson
echo "\033[?1003h\033[?1015h\033[?1006h"
// stty -echo
// But we can still catch them in the STDIN
// We get 16 bits sequences like 35;15;7M where 35 is the mouse move, and the two next numbers are the row and colums numbers + the M ending.

//Then to reset:  echo
mouseoff
"\033[?1000l"

We could similarly catch clicks, mouse wheels, and mouse button wheel. This way we could implement buttons and buffer mouse scrolling. More details on mouse support in this post: https://stackoverflow.com/a/58390575/2494754

Other good one the Clipboard copy:

echo -e '\e]52;c;SGVsbG8gR2l0aHVi'


logy prefix words:
biblio bio chrono ethno topo geo anthro archaeo astro crimin dem etymo
hodo hydr myco neuro paleo pheno psycho socio theo zo
eco mytho philo onco seismo
aero- (aerology: study of the atmosphere)
agro- (agrology: study of soils)
cosmo- (cosmology: study of the universe)
crypto- (cryptology: study of codes)
dendro- (dendrology: study of trees)
eno- (enology: study of wine)
entom- (entomology: study of insects)
glotto- (glottology: study of languages)
graph- (graphology: study of handwriting)
hemato- (hematology: study of blood)
ichthyo- (ichthyology: study of fish)
litho- (lithology: study of rocks)
meteo- (meteorology: study of weather)
morpho- (morphology: study of forms/structures)
nepho- (nephology: study of clouds)
noso- (nosology: study of disease classification)
odonto- (odontology: study of teeth)
orni- (ornithology: study of birds)
patho- (pathology: study of diseases)
phreno- (phrenology: study of skull shapes, now obsolete)
pomo- (pomology: study of fruit)
rheu- (rheumatology: study of rheumatic diseases)
speleo- (speleology: study of caves)
techno- (technology: study/application of techniques)
vexillo- (vexillology: study of flags)

Using these above, you can make pink text like so:

\033[38;5;206m     #That is, \033[38;5;<FG COLOR>m

And make an early-morning blue background using

\033[48;5;57m      #That is, \033[48;5;<BG COLOR>m
And, of course, you can combine these:

\033[38;5;206;48;5;57m
The 8-bit colours are arranged like so:

Range	Description
0x00-0x07	standard colors (same as the 4-bit colours)
0x08-0x0F	high intensity colors
0x10-0xE7	6 × 6 × 6 cube (216 colors): 16 + 36 × r + 6 × g + b (0 ≤ r, g, b ≤ 5)
0xE8-0xFF	grayscale from black to white in 24 steps

class pixels2{
	width: number;
	height: number;
	bits: boolean[];
	constructor(width:number,height:number) {
		this.width = width;
		this.height = height;
		this.bits = new Array(width*height).fill(false);
		const words=(width+15)/16;
	}
	clear(){
		const n=this.bits.length;
		for(let xy=0;xy<n;xy++){
			const r=Math.random();
			this.bits[xy]=r>0.3?true:false;
		}
	}
	frame():string[]{
		const w=this.width;
		const h=this.height;
		const bits=this.bits;
		const cols:number=h/2;
		const rows:number=w/2;
		const lines:string[]=[];
		for(let y:number=0;y<cols;y++){
			let line:string[]=[];
			const y0=2*y*w;
			const y1=y0+w;
			for(let x:number=0;x<rows;x++){
				const b4:boolean[]=[
					bits[y0+x*2+0],
					bits[y0+x*2+1],
					bits[y1+x*2+0],
					bits[y1+x*2+1]
				];
				const index:number=(b4[0]?1:0)+(b4[1]?2:0)+(b4[2]?4:0)+(b4[3]?8:0);
				const q4=quads.charAt(index);
				line.push(q4);
			}
			lines.push(line.join(""));
		}
		return lines;
	}
};



const Leds="⚫⚪🔵🟢🔴🟡🟣🟠🟤";
const dots = ["🟣", "🔵", "🟢", "🟡", "🔴"];

function blankFrame2(){
	const w=32;
	const h=12;
	const bits:boolean[]=new Array(w*h);
	for(let xy=0;xy<w*h;xy++){
		const r=Math.random();
		bits[xy]=r>0.3?true:false;
	}
	const cols=h/2;
	const rows=w/2;
	const lines:string[]=new Array(rows);
	for(let y=0;y<cols;y++){
		let line:string[]=[];
		const y0=2*y*w;
		const y1=y0+w;
		for(let x=0;x<rows;x++){
			const b4:boolean[]=[
				bits[y0+x*2+0],
				bits[y0+x*2+1],
				bits[y1+x*2+0],
				bits[y1+x*2+1]
			];
			const index:number=(b4[0]?1:0)+(b4[1]?2:0)+(b4[2]?4:0)+(b4[3]?8:0);
			const q4=quads.charAt(index);
			line.push(q4);
		}
		lines[y]=line.join("");
	}
	return lines.join("\n");
}



// slop 0.1 const bloks=" ▘▝▗▄▌▞▖▜▚▐▀▛▙▟█"


/*
const blocks=" ▘▝▖▗▌▐▀▄▚▞▛▜▙▟█";
const blockbits=[0, 1,2,4,8, 5,10,3,12,9,6, 7,11,13,14, 15];
let blits=Array(16).fill(" ");
for(let index=0;index<16;index++){
	const bit=blockbits[index];
	blits[bit]=blocks.charAt(index);
}
console.log(blits.join(""));
*/


{
  "hieroglyph": {
    "base": {
      "description": "Egyptian Hieroglyph A001 (Seated Man)",
      "codepoint": "U+13000",
      "character": "𓀀"
    },
    "variants": [
      {
        "rotation": "90 degrees",
        "variation_selector": "VS1",
        "codepoint": "U+13000 U+FE00",
        "character_sequence": "𓀀︀"
      },
      {
        "rotation": "180 degrees",
        "variation_selector": "VS2",
        "codepoint": "U+13000 U+FE01",
        "character_sequence": "𓀀︁"
      }
    ]
  }

"all":
"𓀀𓀁𓀂𓀃𓀄𓀅𓀆𓀇𓀈𓀉𓀊𓀋𓀌𓀍𓀎𓀏𓀐𓀑𓀒𓀓𓀔𓀕𓀖𓀗𓀘𓀙𓀚𓀛𓀜𓀝𓀞𓀟𓀠𓀡𓀢𓀣𓀤𓀥𓀦𓀧𓀨𓀩𓀪𓀫𓀬𓀭𓀮𓀯𓀰𓀱𓀲𓀳𓀴𓀵𓀶𓀷𓀸𓀹𓀺𓀻𓀼𓀽𓀾𓀿𓁀𓁁𓁂𓁃𓁄𓁅𓁆𓁇𓁈𓁉𓁊𓁋𓁌𓁍𓁎𓁏𓁐𓁑𓁒𓁓𓁔𓁕𓁖𓁗𓁘𓁙𓁚𓁛𓁜𓁝𓁞𓁟𓁠𓁡𓁢𓁣𓁤𓁥𓁦𓁧𓁨𓁩𓁪𓁫𓁬𓁭𓁮𓁯𓁰𓁱𓁲𓁳𓁴𓁵𓁶𓁷𓁸𓁹𓁺𓁻𓁼𓁽𓁾𓁿𓂀𓂁𓂂𓂃𓂄𓂅𓂆𓂇𓂈𓂉𓂊𓂋𓂌𓂍𓂎𓂏𓂐𓂑𓂒𓂓𓂔𓂕𓂖𓂗𓂘𓂙𓂚𓂛𓂜𓂝𓂞𓂟𓂠𓂡𓂢𓂣𓂤𓂥𓂦𓂧𓂨𓂩𓂪𓂫𓂬𓂭𓂮𓂯𓂰𓂱𓂲𓂳𓂴𓂵𓂶𓂷𓂸𓂹𓂺𓂻𓂼𓂽𓂾𓂿𓃀𓃁𓃂𓃃𓃄𓃅𓃆𓃇𓃈𓃉𓃊𓃋𓃌𓃍𓃎𓃏𓃐𓃑𓃒𓃓𓃔𓃕𓃖𓃗𓃘𓃙𓃚𓃛𓃜𓃝𓃞𓃟𓃠𓃡𓃢𓃣𓃤𓃥𓃦𓃧𓃨𓃩𓃪𓃫𓃬𓃭𓃮𓃯𓃰𓃱𓃲𓃳𓃴𓃵𓃶𓃷𓃸𓃹𓃺𓃻𓃼𓃽𓃾𓃿𓄀𓄁𓄂𓄃𓄄𓄅𓄆𓄇𓄈𓄉𓄊𓄋𓄌𓄍𓄎𓄏𓄐𓄑𓄒𓄓𓄔𓄕𓄖𓄗𓄘𓄙𓄚𓄛𓄜𓄝𓄞𓄟𓄠𓄡𓄢𓄣𓄤𓄥𓄦𓄧𓄨𓄩𓄪𓄫𓄬𓄭𓄮𓄯𓄰𓄱𓄲𓄳𓄴𓄵𓄶𓄷𓄸𓄹𓄺𓄻𓄼𓄽𓄾𓄿𓅀𓅁𓅂𓅃𓅄𓅅𓅆𓅇𓅈𓅉𓅊𓅋𓅌𓅍𓅎𓅏𓅐𓅑𓅒𓅓𓅔𓅕𓅖𓅗𓅘𓅙𓅚𓅛𓅜𓅝𓅞𓅟𓅠𓅡𓅢𓅣𓅤𓅥𓅦𓅧𓅨𓅩𓅪𓅫𓅬𓅭𓅮𓅯𓅰𓅱𓅲𓅳𓅴𓅵𓅶𓅷𓅸𓅹𓅺𓅻𓅼𓅽𓅾𓅿𓆀𓆁𓆂𓆃𓆄𓆅𓆆𓆇𓆈𓆉𓆊𓆋𓆌𓆍𓆎𓆏𓆐𓆑𓆒𓆓𓆔𓆕𓆖𓆗𓆘𓆙𓆚𓆛𓆜𓆝𓆞𓆟𓆠𓆡𓆢𓆣𓆤𓆥𓆦𓆧𓆨𓆩𓆪𓆫𓆬𓆭𓆮𓆯𓆰𓆱𓆲𓆳𓆴𓆵𓆶𓆷𓆸𓆹𓆺𓆻𓆼𓆽𓆾𓆿𓇀𓇁𓇂𓇃𓇄𓇅𓇆𓇇𓇈𓇉𓇊𓇋𓇌𓇍𓇎𓇏𓇐𓇑𓇒𓇓𓇔𓇕𓇖𓇗𓇘𓇙𓇚𓇛𓇜𓇝𓇞𓇟𓇠𓇡𓇢𓇣𓇤𓇥𓇦𓇧𓇨𓇩𓇪𓇫𓇬𓇭𓇮𓇯𓇰𓇱𓇲𓇳𓇴𓇵𓇶𓇷𓇸𓇹𓇺𓇻𓇼𓇽𓇾𓇿𓈀𓈁𓈂𓈃𓈄𓈅𓈆𓈇𓈈𓈉𓈊𓈋𓈌𓈍𓈎𓈏𓈐𓈑𓈒𓈓𓈔𓈕𓈖𓈗𓈘𓈙𓈚𓈛𓈜𓈝𓈞𓈟𓈠𓈡𓈢𓈣𓈤𓈥𓈦𓈧𓈨𓈩𓈪𓈫𓈬𓈭𓈮𓈯𓈰𓈱𓈲𓈳𓈴𓈵𓈶𓈷𓈸𓈹𓈺𓈻𓈼𓈽𓈾𓈿𓉀𓉁𓉂𓉃𓉄𓉅𓉆𓉇𓉈𓉉𓉊𓉋𓉌𓉍𓉎𓉏𓉐𓉑𓉒𓉓𓉔𓉕𓉖𓉗𓉘𓉙𓉚𓉛𓉜𓉝𓉞𓉟𓉠𓉡𓉢𓉣𓉤𓉥𓉦𓉧𓉨𓉩𓉪𓉫𓉬𓉭𓉮𓉯𓉰𓉱𓉲𓉳𓉴𓉵𓉶𓉷𓉸𓉹𓉺𓉻𓉼𓉽𓉾𓉿𓊀𓊁𓊂𓊃𓊄𓊅𓊆𓊇𓊈𓊉𓊊𓊋𓊌𓊍𓊎𓊏𓊐𓊑𓊒𓊓𓊔𓊕𓊖𓊗𓊘𓊙𓊚𓊛𓊜𓊝𓊞𓊟𓊠𓊡𓊢𓊣𓊤𓊥𓊦𓊧𓊨𓊩𓊪𓊫𓊬𓊭𓊮𓊯𓊰𓊱𓊲𓊳𓊴𓊵𓊶𓊷𓊸𓊹𓊺𓊻𓊼𓊽𓊾𓊿𓋀𓋁𓋂𓋃𓋄𓋅𓋆𓋇𓋈𓋉𓋊𓋋𓋌𓋍𓋎𓋏𓋐𓋑𓋒𓋓𓋔𓋕𓋖𓋗𓋘𓋙𓋚𓋛𓋜𓋝𓋞𓋟𓋠𓋡𓋢𓋣𓋤𓋥𓋦𓋧𓋨𓋩𓋪𓋫𓋬𓋭𓋮𓋯𓋰𓋱𓋲𓋳𓋴𓋵𓋶𓋷𓋸𓋹𓋺𓋻𓋼𓋽𓋾𓋿𓌀𓌁𓌂𓌃𓌄𓌅𓌆𓌇𓌈𓌉𓌊𓌋𓌌𓌍𓌎𓌏𓌐𓌑𓌒𓌓𓌔𓌕𓌖𓌗𓌘𓌙𓌚𓌛𓌜𓌝𓌞𓌟𓌠𓌡𓌢𓌣𓌤𓌥𓌦𓌧𓌨𓌩𓌪𓌫𓌬𓌭𓌮𓌯𓌰𓌱𓌲𓌳𓌴𓌵𓌶𓌷𓌸𓌹𓌺𓌻𓌼𓌽𓌾𓌿𓍀𓍁𓍂𓍃𓍄𓍅𓍆𓍇𓍈𓍉𓍊𓍋𓍌𓍍𓍎𓍏𓍐𓍑𓍒𓍓𓍔𓍕𓍖𓍗𓍘𓍙𓍚𓍛𓍜𓍝𓍞𓍟𓍠𓍡𓍢𓍣𓍤𓍥𓍦𓍧𓍨𓍩𓍪𓍫𓍬𓍭𓍮𓍯𓍰𓍱𓍲𓍳𓍴𓍵𓍶𓍷𓍸𓍹𓍺𓍻𓍼𓍽𓍾𓍿𓎀𓎁𓎂𓎃𓎄𓎅𓎆𓎇𓎈𓎉𓎊𓎋𓎌𓎍𓎎𓎏𓎐𓎑𓎒𓎓𓎔𓎕𓎖𓎗𓎘𓎙𓎚𓎛𓎜𓎝𓎞𓎟𓎠𓎡𓎢𓎣𓎤𓎥𓎦𓎧𓎨𓎩𓎪𓎫𓎬𓎭𓎮𓎯𓎰𓎱𓎲𓎳𓎴𓎵𓎶𓎷𓎸𓎹𓎺𓎻𓎼𓎽𓎾𓎿𓏀𓏁𓏂𓏃𓏄𓏅𓏆𓏇𓏈𓏉𓏊𓏋𓏌𓏍𓏎𓏏𓏐𓏑𓏒𓏓𓏔𓏕𓏖𓏗𓏘𓏙𓏚𓏛𓏜𓏝𓏞𓏟𓏠𓏡𓏢𓏣𓏤𓏥𓏦𓏧𓏨𓏩𓏪𓏫𓏬𓏭𓏮𓏯𓏰𓏱𓏲𓏳𓏴𓏵𓏶𓏷𓏸𓏹𓏺𓏻𓏼𓏽𓏾𓏿𓐀𓐁𓐂𓐃𓐄𓐅𓐆𓐇𓐈𓐉𓐊𓐋𓐌𓐍𓐎𓐏𓐐𓐑𓐒𓐓𓐔𓐕𓐖𓐗𓐘𓐙𓐚𓐛𓐜𓐝𓐞𓐟𓐠𓐡𓐢𓐣𓐤𓐥𓐦𓐧𓐨𓐩𓐪𓐫𓐬𓐭𓐮𓐯",

cartouches


{
	"𓃱": "giraffe"
	"𓃰": "elephant"
	"𓃬": "lion",
	"𓃮": "leopard",
	"𓃲": "oryx",
	"𓃴": "gazelle",
	"𓃯": "hippo",
	"𓃥": "jackal",
	"𓃦": "hyena",
	"𓃸": "monkey",
	"𓃷": "baboon",
	"𓃗": "horse",
	"𓃘": "donkey",
	"𓃟": "pig",
	"𓃒": "bull",
	"𓃚": "kid",
	"𓃔": "calf",
	"𓃖": "suckling",
	"𓃠": "cat",
	"𓃡": "dog"
}

Aegyptus, Regular

Egyptian Hieroglyphs
Unicode version 5.2

Lo,Egyp
General classified as "Other_Letter" (Lo)
Script value "Egyptian Hieroglyphs" (Egyp).

[U+13000,U+1342F] encompassing 1,072 assigned code
[U+13460,U+143FF] Egyptian Hieroglyphs Extended-A

Gardiner’s Sign List 763 signs across 26 categories (A–Z) various in AA

use : classifiers ideograms phonograms

standardized variants for rotated signs (100)
	VS1: U+FE00 for 90° rotation (40)
	VS2: U+FE01 for 180° rotation (22)

{
	"A": {
		"name": "Man and His Occupations",
		"description": "Signs depicting human figures, actions, or roles such as seated man, king, or soldier.",
		"count": 59
	},
	"B": {
		"name": "Woman and Her Occupations",
		"description": "Signs of women, female roles, or activities like seated woman or queen.",
		"count": 7
	},
	"C": {
		"name": "Anthropomorphic Deities",
		"description": "Deities with human-like forms, such as gods like Osiris or Horus.",
		"count": 11
	},
	"D": {
		"name": "Parts of the Human Body",
		"description": "Body parts like eye, hand, or leg.",
		"count": 63,
	},
	"E": {
		"name": "Mammals",
		"description": "Mammalian animals, including cat, lion, or cow.",
		"count": 34,
	},
	"F": {
		"name": "Parts of Mammals",
		"description": "Animal body parts such as horn or tail.",
		"count": 32,
	},
	"G": {
		"name": "Birds",
		"description": "Bird species and related signs, like owl or vulture.",
		"count": 54,
	},
	"H": {
		"name": "Parts of Birds",
		"description": "Bird body parts, such as wing or feather.",
		"count": 8
	},
	"I": {
		"name": "Amphibious Animals, Reptiles, etc.",
		"description": "Reptiles and amphibians, like snake or crocodile.",
		"count": 15
	},
	"K": {
		"name": "Fish and Parts of Fish",
		"description": "Fish and fish-related signs, such as fish or fin.",
		"count": 6,
	},
	"L": {
		"name": "Invertebrates and Lesser Animals",
		"description": "Insects and small creatures, like bee or scorpion.",
		"count": 7,
	},
	"M": {
		"name": "Trees and Plants",
		"description": "Vegetation, such as reed or lotus.",
		"count": 44,
	},
	"N": {
		"name": "Sky, Earth, Water",
		"description": "Natural features like sky, mountain, or water.",
		"count": 42
	},
	"O": {
		"name": "Buildings, Parts of Buildings, etc.",
		"description": "Architectural elements, such as house or pyramid.",
		"count": 51
	},
	"P": {
		"name": "Ships, Parts of Ships, etc.",
		"description": "Watercraft and related signs, like boat or sail.",
		"count": 11
	},
	"Q": {
		"name": "Domestic and Funerary Furniture",
		"description": "Household items, such as chair or bed.",
		"count": 7
	},
	"R": {
		"name": "Temple Furniture and Sacred Emblems",
		"description": "Religious objects, like altar or ankh.",
		"count": 25
	},
	"S": {
		"name": "Crowns, Dress, Staves, etc.",
		"description": "Regalia and symbols of power, such as crown or scepter.",
		"count": 45
	},
	"T": {
		"name": "Warfare, Hunting, Butchery",
		"description": "Weapons and tools, like bow or knife.",
		"count": 35
	},
	"U": {
		"name": "Agriculture, Crafts, and Professions",
		"description": "Tools and activities, such as plow or adze.",
		"count": 41
	},
	"V": {
		"name": "Rope, Fiber, Baskets, Bags, etc.",
		"description": "Cordage and containers, like rope or basket.",
		"count": 39
	},
	"W": {
		"name": "Vessels of Stone and Earthenware",
		"description": "Containers, such as jar or pot.",
		"count": 25
	},
	"X": {
		"name": "Loaves and Cakes",
		"description": "Bread and food items, like loaf.",
		"count": 8
	},
	"Y": {
		"name": "Writings, Games, Music",
		"description": "Cultural objects, such as scroll or harp.",
		"count": 8
	},
	"Z": {
		"name": "Strokes, Signs Derived from Hieratic, Geometrical Figures",
		"description": "Lines and shapes, like single stroke.",
		"count": 11
	},
	"AA": {
		"name": "Unclassified",
		"description": "Miscellaneous signs not fitting other categories.",
		"count": 31
	}
}


𓉴𓊽𓊽𓊽𓊽𓊽𓉴𓊽𓊽𓊽𓊽𓊽𓉴𓊽𓊽𓊽𓊽𓊽𓉴𓊽𓊽𓊽𓊽𓊽𓉴𓊽𓊽𓊽𓊽𓊽𓉴𓉵𓉵𓉵𓉵𓉵𓉴𓊽𓊽𓊽𓊽𓊽𓉴𓊽𓊽𓊽𓊽𓊽𓉴𓊽𓊽𓊽𓊽𓊽𓉴𓊽𓊽𓊽𓊽𓊽𓉴𓊽𓊽𓊽𓊽𓊽𓉴

U+1300x	𓀀	𓀁	𓀂	𓀃	𓀄	𓀅	𓀆	𓀇	𓀈	𓀉	𓀊	𓀋	𓀌	𓀍	𓀎	𓀏
U+1301x	𓀐	𓀑	𓀒	𓀓	𓀔	𓀕	𓀖	𓀗	𓀘	𓀙	𓀚	𓀛	𓀜	𓀝	𓀞	𓀟
U+1302x	𓀠	𓀡	𓀢	𓀣	𓀤	𓀥	𓀦	𓀧	𓀨	𓀩	𓀪	𓀫	𓀬	𓀭	𓀮	𓀯
U+1303x	𓀰	𓀱	𓀲	𓀳	𓀴	𓀵	𓀶	𓀷	𓀸	𓀹	𓀺	𓀻	𓀼	𓀽	𓀾	𓀿
U+1304x	𓁀	𓁁	𓁂	𓁃	𓁄	𓁅	𓁆	𓁇	𓁈	𓁉	𓁊	𓁋	𓁌	𓁍	𓁎	𓁏
U+1305x	𓁐	𓁑	𓁒	𓁓	𓁔	𓁕	𓁖	𓁗	𓁘	𓁙	𓁚	𓁛	𓁜	𓁝	𓁞	𓁟
U+1306x	𓁠	𓁡	𓁢	𓁣	𓁤	𓁥	𓁦	𓁧	𓁨	𓁩	𓁪	𓁫	𓁬	𓁭	𓁮	𓁯
U+1307x	𓁰	𓁱	𓁲	𓁳	𓁴	𓁵	𓁶	𓁷	𓁸	𓁹	𓁺	𓁻	𓁼	𓁽	𓁾	𓁿
U+1308x	𓂀	𓂁	𓂂	𓂃	𓂄	𓂅	𓂆	𓂇	𓂈	𓂉	𓂊	𓂋	𓂌	𓂍	𓂎	𓂏
U+1309x	𓂐	𓂑	𓂒	𓂓	𓂔	𓂕	𓂖	𓂗	𓂘	𓂙	𓂚	𓂛	𓂜	𓂝	𓂞	𓂟
U+130Ax	𓂠	𓂡	𓂢	𓂣	𓂤	𓂥	𓂦	𓂧	𓂨	𓂩	𓂪	𓂫	𓂬	𓂭	𓂮	𓂯
U+130Bx	𓂰	𓂱	𓂲	𓂳	𓂴	𓂵	𓂶	𓂷	𓂸	𓂹	𓂺	𓂻	𓂼	𓂽	𓂾	𓂿
U+130Cx	𓃀	𓃁	𓃂	𓃃	𓃄	𓃅	𓃆	𓃇	𓃈	𓃉	𓃊	𓃋	𓃌	𓃍	𓃎	𓃏
U+130Dx	𓃐	𓃑	𓃒	𓃓	𓃔	𓃕	𓃖	𓃗	𓃘	𓃙	𓃚	𓃛	𓃜	𓃝	𓃞	𓃟
U+130Ex	𓃠	𓃡	𓃢	𓃣	𓃤	𓃥	𓃦	𓃧	𓃨	𓃩	𓃪	𓃫	𓃬	𓃭	𓃮	𓃯
U+130Fx	𓃰	𓃱	𓃲	𓃳	𓃴	𓃵	𓃶	𓃷	𓃸	𓃹	𓃺	𓃻	𓃼	𓃽	𓃾	𓃿
U+1310x	𓄀	𓄁	𓄂	𓄃	𓄄	𓄅	𓄆	𓄇	𓄈	𓄉	𓄊	𓄋	𓄌	𓄍	𓄎	𓄏
U+1311x	𓄐	𓄑	𓄒	𓄓	𓄔	𓄕	𓄖	𓄗	𓄘	𓄙	𓄚	𓄛	𓄜	𓄝	𓄞	𓄟
U+1312x	𓄠	𓄡	𓄢	𓄣	𓄤	𓄥	𓄦	𓄧	𓄨	𓄩	𓄪	𓄫	𓄬	𓄭	𓄮	𓄯
U+1313x	𓄰	𓄱	𓄲	𓄳	𓄴	𓄵	𓄶	𓄷	𓄸	𓄹	𓄺	𓄻	𓄼	𓄽	𓄾	𓄿
U+1314x	𓅀	𓅁	𓅂	𓅃	𓅄	𓅅	𓅆	𓅇	𓅈	𓅉	𓅊	𓅋	𓅌	𓅍	𓅎	𓅏
U+1315x	𓅐	𓅑	𓅒	𓅓	𓅔	𓅕	𓅖	𓅗	𓅘	𓅙	𓅚	𓅛	𓅜	𓅝	𓅞	𓅟
U+1316x	𓅠	𓅡	𓅢	𓅣	𓅤	𓅥	𓅦	𓅧	𓅨	𓅩	𓅪	𓅫	𓅬	𓅭	𓅮	𓅯
U+1317x	𓅰	𓅱	𓅲	𓅳	𓅴	𓅵	𓅶	𓅷	𓅸	𓅹	𓅺	𓅻	𓅼	𓅽	𓅾	𓅿
U+1318x	𓆀	𓆁	𓆂	𓆃	𓆄	𓆅	𓆆	𓆇	𓆈	𓆉	𓆊	𓆋	𓆌	𓆍	𓆎	𓆏
U+1319x	𓆐	𓆑	𓆒	𓆓	𓆔	𓆕	𓆖	𓆗	𓆘	𓆙	𓆚	𓆛	𓆜	𓆝	𓆞	𓆟
U+131Ax	𓆠	𓆡	𓆢	𓆣	𓆤	𓆥	𓆦	𓆧	𓆨	𓆩	𓆪	𓆫	𓆬	𓆭	𓆮	𓆯
U+131Bx	𓆰	𓆱	𓆲	𓆳	𓆴	𓆵	𓆶	𓆷	𓆸	𓆹	𓆺	𓆻	𓆼	𓆽	𓆾	𓆿
U+131Cx	𓇀	𓇁	𓇂	𓇃	𓇄	𓇅	𓇆	𓇇	𓇈	𓇉	𓇊	𓇋	𓇌	𓇍	𓇎	𓇏
U+131Dx	𓇐	𓇑	𓇒	𓇓	𓇔	𓇕	𓇖	𓇗	𓇘	𓇙	𓇚	𓇛	𓇜	𓇝	𓇞	𓇟
U+131Ex	𓇠	𓇡	𓇢	𓇣	𓇤	𓇥	𓇦	𓇧	𓇨	𓇩	𓇪	𓇫	𓇬	𓇭	𓇮	𓇯
U+131Fx	𓇰	𓇱	𓇲	𓇳	𓇴	𓇵	𓇶	𓇷	𓇸	𓇹	𓇺	𓇻	𓇼	𓇽	𓇾	𓇿
U+1320x	𓈀	𓈁	𓈂	𓈃	𓈄	𓈅	𓈆	𓈇	𓈈	𓈉	𓈊	𓈋	𓈌	𓈍	𓈎	𓈏
U+1321x	𓈐	𓈑	𓈒	𓈓	𓈔	𓈕	𓈖	𓈗	𓈘	𓈙	𓈚	𓈛	𓈜	𓈝	𓈞	𓈟
U+1322x	𓈠	𓈡	𓈢	𓈣	𓈤	𓈥	𓈦	𓈧	𓈨	𓈩	𓈪	𓈫	𓈬	𓈭	𓈮	𓈯
U+1323x	𓈰	𓈱	𓈲	𓈳	𓈴	𓈵	𓈶	𓈷	𓈸	𓈹	𓈺	𓈻	𓈼	𓈽	𓈾	𓈿
U+1324x	𓉀	𓉁	𓉂	𓉃	𓉄	𓉅	𓉆	𓉇	𓉈	𓉉	𓉊	𓉋	𓉌	𓉍	𓉎	𓉏
U+1325x	𓉐	𓉑	𓉒	𓉓	𓉔	𓉕	𓉖	𓉗	𓉘	𓉙	𓉚	𓉛	𓉜	𓉝	𓉞	𓉟
U+1326x	𓉠	𓉡	𓉢	𓉣	𓉤	𓉥	𓉦	𓉧	𓉨	𓉩	𓉪	𓉫	𓉬	𓉭	𓉮	𓉯
U+1327x	𓉰	𓉱	𓉲	𓉳	𓉴	𓉵	𓉶	𓉷	𓉸	𓉹	𓉺	𓉻	𓉼	𓉽	𓉾	𓉿
U+1328x	𓊀	𓊁	𓊂	𓊃	𓊄	𓊅	𓊆	𓊇	𓊈	𓊉	𓊊	𓊋	𓊌	𓊍	𓊎	𓊏
U+1329x	𓊐	𓊑	𓊒	𓊓	𓊔	𓊕	𓊖	𓊗	𓊘	𓊙	𓊚	𓊛	𓊜	𓊝	𓊞	𓊟
U+132Ax	𓊠	𓊡	𓊢	𓊣	𓊤	𓊥	𓊦	𓊧	𓊨	𓊩	𓊪	𓊫	𓊬	𓊭	𓊮	𓊯
U+132Bx	𓊰	𓊱	𓊲	𓊳	𓊴	𓊵	𓊶	𓊷	𓊸	𓊹	𓊺	𓊻	𓊼	𓊽	𓊾	𓊿
U+132Cx	𓋀	𓋁	𓋂	𓋃	𓋄	𓋅	𓋆	𓋇	𓋈	𓋉	𓋊	𓋋	𓋌	𓋍	𓋎	𓋏
U+132Dx	𓋐	𓋑	𓋒	𓋓	𓋔	𓋕	𓋖	𓋗	𓋘	𓋙	𓋚	𓋛	𓋜	𓋝	𓋞	𓋟
U+132Ex	𓋠	𓋡	𓋢	𓋣	𓋤	𓋥	𓋦	𓋧	𓋨	𓋩	𓋪	𓋫	𓋬	𓋭	𓋮	𓋯
U+132Fx	𓋰	𓋱	𓋲	𓋳	𓋴	𓋵	𓋶	𓋷	𓋸	𓋹	𓋺	𓋻	𓋼	𓋽	𓋾	𓋿
U+1330x	𓌀	𓌁	𓌂	𓌃	𓌄	𓌅	𓌆	𓌇	𓌈	𓌉	𓌊	𓌋	𓌌	𓌍	𓌎	𓌏
U+1331x	𓌐	𓌑	𓌒	𓌓	𓌔	𓌕	𓌖	𓌗	𓌘	𓌙	𓌚	𓌛	𓌜	𓌝	𓌞	𓌟
U+1332x	𓌠	𓌡	𓌢	𓌣	𓌤	𓌥	𓌦	𓌧	𓌨	𓌩	𓌪	𓌫	𓌬	𓌭	𓌮	𓌯
U+1333x	𓌰	𓌱	𓌲	𓌳	𓌴	𓌵	𓌶	𓌷	𓌸	𓌹	𓌺	𓌻	𓌼	𓌽	𓌾	𓌿
U+1334x	𓍀	𓍁	𓍂	𓍃	𓍄	𓍅	𓍆	𓍇	𓍈	𓍉	𓍊	𓍋	𓍌	𓍍	𓍎	𓍏
U+1335x	𓍐	𓍑	𓍒	𓍓	𓍔	𓍕	𓍖	𓍗	𓍘	𓍙	𓍚	𓍛	𓍜	𓍝	𓍞	𓍟
U+1336x	𓍠	𓍡	𓍢	𓍣	𓍤	𓍥	𓍦	𓍧	𓍨	𓍩	𓍪	𓍫	𓍬	𓍭	𓍮	𓍯
U+1337x	𓍰	𓍱	𓍲	𓍳	𓍴	𓍵	𓍶	𓍷	𓍸	𓍹	𓍺	𓍻	𓍼	𓍽	𓍾	𓍿
U+1338x	𓎀	𓎁	𓎂	𓎃	𓎄	𓎅	𓎆	𓎇	𓎈	𓎉	𓎊	𓎋	𓎌	𓎍	𓎎	𓎏
U+1339x	𓎐	𓎑	𓎒	𓎓	𓎔	𓎕	𓎖	𓎗	𓎘	𓎙	𓎚	𓎛	𓎜	𓎝	𓎞	𓎟
U+133Ax	𓎠	𓎡	𓎢	𓎣	𓎤	𓎥	𓎦	𓎧	𓎨	𓎩	𓎪	𓎫	𓎬	𓎭	𓎮	𓎯
U+133Bx	𓎰	𓎱	𓎲	𓎳	𓎴	𓎵	𓎶	𓎷	𓎸	𓎹	𓎺	𓎻	𓎼	𓎽	𓎾	𓎿
U+133Cx	𓏀	𓏁	𓏂	𓏃	𓏄	𓏅	𓏆	𓏇	𓏈	𓏉	𓏊	𓏋	𓏌	𓏍	𓏎	𓏏
U+133Dx	𓏐	𓏑	𓏒	𓏓	𓏔	𓏕	𓏖	𓏗	𓏘	𓏙	𓏚	𓏛	𓏜	𓏝	𓏞	𓏟
U+133Ex	𓏠	𓏡	𓏢	𓏣	𓏤	𓏥	𓏦	𓏧	𓏨	𓏩	𓏪	𓏫	𓏬	𓏭	𓏮	𓏯
U+133Fx	𓏰	𓏱	𓏲	𓏳	𓏴	𓏵	𓏶	𓏷	𓏸	𓏹	𓏺	𓏻	𓏼	𓏽	𓏾	𓏿
U+1340x	𓐀	𓐁	𓐂	𓐃	𓐄	𓐅	𓐆	𓐇	𓐈	𓐉	𓐊	𓐋	𓐌	𓐍	𓐎	𓐏
U+1341x	𓐐	𓐑	𓐒	𓐓	𓐔	𓐕	𓐖	𓐗	𓐘	𓐙	𓐚	𓐛	𓐜	𓐝	𓐞	𓐟
U+1342x	𓐠	𓐡	𓐢	𓐣	𓐤	𓐥	𓐦	𓐧	𓐨	𓐩	𓐪	𓐫	𓐬	𓐭	𓐮	𓐯
